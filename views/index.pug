extends ./main-layout.pug

block content
    ul.collapsible
        li
            .collapsible-header 
                strong Input
            .collapsible-body
                .row
                    .input-field.col.s12
                        label(for="panelAmount") Solar panel amount
                        input(type="number", id="panelAmount")
                    .input-field.col.s12
                        label(for="inverterAmount") Inverter amount
                        input(type="number", id="inverterAmount")
                    .input-field.col.s12
                        label(for="mppAmount") MPP Tracker amount
                        input(type="number", id="mppAmount")
                    .input-field.col.s6
                        label(for="stringMin") Smallest string size
                        input(type="number", id="stringMin")
                    .input-field.col.s6
                        label(for="stringMax") Biggest string size
                        input(type="number", id="stringMax")
                    .input-field.col.s12
                        button.btn(onclick="calc();") Calculate
    .container#result
block script
    script.
        let inputCollaps;
        document.addEventListener('DOMContentLoaded', function() {
            const selects = document.querySelector('select');
            M.FormSelect.init(selects);
            const collaps = document.querySelector('.collapsible');
            inputCollaps = M.Collapsible.init(collaps, {
                onOpenStart: () => {
                    result.style = "opacity: 0;";
                },
                onCloseStart: () => {
                    result.style = "opacity: 1;";
                }
            });
            setTimeout(() => {
                inputCollaps.open();
            }, 500)
        });

        const result = document.getElementById("result");

        const check = (amount, strings) => {
            for(let i = strings.length - 1; i > -1; i--) {
                if(amount % strings[i] === 0) return strings[i];
            }
            return false;
        };

        const testInverter = (inverter, strings) => {
            for(let i = 0; i < inverter.length; i++) {
                let lock = true;
                while(lock) {
                    if(check(inverter[i], strings)) {
                        lock = false;
                    }
                    else {
                        inverter[i].panels -= 1;
                        if(i + 1 >= inverter.length) return console.log(i + 1, inverter.length);
                        inverter[i + 1].panels += 1;
                    }
                }
            }
        };

        const testMPP = (mpp, strings) => new Promise((resolve, reject) => {
            for(let i = 0; i < mpp.length; i++) {
                let lock = true;
                while(lock) {
                    if(check(mpp[i].panels, strings)) {
                        mpp[i].stringSize = check(mpp[i].panels, strings);
                        mpp[i].strings = mpp[i].panels / mpp[i].stringSize;
                        lock = false;
                    }
                    else {
                        if(mpp[i].panels <= 0) return reject("smaller than zero");
                        if(i + 1 >= mpp.length) {
                            i = 0;
                        }
                        mpp[i].panels -= 1;
                        mpp[i + 1].panels += 1;
                    }
                }
            }
            return resolve();
        });

        const printResult = data => {
            for(let i = 0; i < data.inverter.length; i++) {
                result.innerHTML += "<h6>Inverter " + (i + 1) + "</h6>";
                for(let j = 0; j < data.inverter[i].mpp.length; j++) {
                    result.innerHTML += "<strong>MPP Tracker " + (j + 1) + "</strong><br>";
                    result.innerHTML += "<span>&emsp;Panelamount: " + data.inverter[i].mpp[j].panels + "</span><br>";
                    result.innerHTML += "<span>&emsp;Stringamount: " + data.inverter[i].mpp[j].strings + "</span><br>";
                    result.innerHTML += "<span>&emsp;Stringsize: " + data.inverter[i].mpp[j].stringSize + "</span><br><br>";
                }
                result.innerHTML += "<hr>";
            }
        };

        const calc = async () => {
            //- Ergebnissanzeige löschen
            result.innerHTML = "";

            //- Werte importieren
            const panels = Number(document.getElementById("panelAmount").value);
            const inverter = Number(document.getElementById("inverterAmount").value);
            const mpp = Number(document.getElementById("mppAmount").value);
            const stringMin = Number(document.getElementById("stringMin").value);
            const stringMax = Number(document.getElementById("stringMax").value);

            //- Datenset deklarieren
            const data = {
                panels,
                inverter: [],
                strings: []
            };

            //- Strings definieren
            if(stringMin < stringMax) {
                for(let i = stringMin; i <= stringMax; i++) {
                    data.strings.push(i);
                }
            }
            else {
                for(let i = stringMax; i <= stringMin; i++) {
                    data.strings.push(i);
                }
            }

            //- Panelanzahl durch Inverteranzahl dividieren
            for(let i = 0; i < inverter; i++) {
                data.inverter.push({
                    panels: Math.round(data.panels / inverter),
                    mpp: []
                });
            }
            
            
            //- Panelanzahl der Inverter der Gesamtanzahl abgleichen
            if(data.inverter.length > 1) {
                const panelSum = data.inverter.reduce((a,b) => {
                    return { panels: a.panels + b.panels }
                });
                const inverterDiff = panels - panelSum.panels;
                if(inverterDiff !== 0) data.inverter[data.inverter.length - 1].panels += inverterDiff;
            }

            //- Panelanzahl je Inverter durch MPP Tracker dividieren.
            try {
                for(let i = 0; i < inverter; i++) {
                    for(let j = 0; j < mpp; j++) {
                        data.inverter[i].mpp.push({
                            panels: Math.round(data.inverter[i].panels / mpp),
                            stringSize: undefined,
                            strings: undefined
                        });
                    }

                    //- Panelanzahl der MPP der Inverteranzahl abgleichen
                    if(data.inverter[i].mpp.length > 1) {
                        const panelSum = data.inverter[i].mpp.reduce((a,b) => {
                            return { panels: a.panels + b.panels };
                        });
                        const mppDiff = data.inverter[i].panels - panelSum.panels;
                        if(mppDiff !== 0) data.inverter[i].mpp[data.inverter[i].mpp.length - 1].panels += mppDiff;
                    }

                    //- Überprüfen ob die Panelanzahl der MPP Tracker geteilt werden kann.
                    await testMPP(data.inverter[i].mpp, data.strings);
                }
            }
            catch (error) {
                inputCollaps.close();
                result.innerHTML = "<p>No possible wiring available!</p>";
                return result.style = "color: red !important;";
            }
            inputCollaps.close();
            return printResult(data);
        };